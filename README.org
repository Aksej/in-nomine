
#+BEGIN_SRC
Long time ago, in a galaxy far far away... 

There used to be a civil war. Lisp
aliens, striking from the function
namespace, have fought for the
design of their language against lisp-1.

After the battle, some aliens managed
to find an easy way to the lisper's
moderate weapon, LISP-N, an
not-so-developed idea with enough
power to provide arbitrary number of namespaces.

Pursued by the lot's of let+destructuring libraries,
this small library provides ....
#+END_SRC

Well, this would be enough. Flat joke.

* Introduction

There are several libraries for extending the semantics of =let=.
However, destructuring is merely
a syntax sugar for writing the accessor. Moreover, it is now considered
obsolete: it is superseded by pattern-matching many years ago, which
cleanly combines =cond=, =typecase= and destructuring.

Those =let= extensions are subject to a variation of greenspun's rule: they
are the /ad hoc, informally-specified, bug-ridden, slow implementation of
half of pattern-matching in ML/. (And I favor [[https://github.com/m2ym/optima][optima]] in this sense.) Now it
comes to my mind: what could be *the other* orthogonal aspect
that could be combined with =let=, or, =let + cond = pattern matching= ?

Then I noticed an oddness in flet, macrolet, labels, let,
symbol-macrolet. Special bindings for /namespaces/ can be trivially
implemented with a hash table, but the lexical binding is not --- it's
worth a library.  This is what this library is for.

* Namespaces in CL

By /namespace/ I don't mean a /package/,
which is a way to manage symbols and orthogonal to /namespace/.

CL already has major 2 namespaces, /function/ namespace and /value/
namespace, but there are actually more --- e.g., there are also /class/
namespace and /package/ namespace. Same symbol can represent different
objects in each namespace. For example, all these below can coexist in a
same file without errors, and each object is accessible with the
corresponding function.

#+BEGIN_SRC lisp
(in-package :cl-user)

(defclass foo () ())
(defun foo () nil)
(defvar foo 1)
(defpackage foo)

(find-class 'foo)      ; -> #<STANDARD-CLASS FOO>
(symbol-value 'foo)    ; -> 1
(symbol-function 'foo) ; -> #<FUNCTION FOO>
(find-package "FOO")  ; -> #<PACKAGE "FOO">

(make-instance 'bar)   ; -> SIMPLE-ERROR
(symbol-value 'bar)    ; -> UNBOUND-VARIABLE
(symbol-function 'bar) ; -> UNDEFINED-FUNCTION
(bar:x)                ; -> PACKAGE-ERROR
#+END_SRC

| namespace | accessor        | unbound condition  | boundp  | binding     |
|-----------+-----------------+--------------------+---------+-------------|
| class     | find-class      | SIMPLE-ERROR       | n/a     | n/a         |
| value     | symbol-value    | UNBOUND-VARIABLE   | boundp  | let         |
| function  | symbol-function | UNDEFINED-FUNCTION | fboundp | flet,labels |
| package   | find-package    | PACKAGE-ERROR      | n/a     | n/a         |

/Some/ namespaces in CL can be said to overlap with each other. For example:

+ *type* namespace --- with *class*, *condition* and *struct* namespace
+ *function* namspace --- with *macro-function* and *generic-function* namespace
+ *value* namespace --- with *symbol-macro* namespace.

* Macro DEFINE-NAMESPACE

: (define-namespace name &optional expected-type)

This macro defines a namespace. For the given name X of namespace ,
DEFINE-NAMESPACE defines 4 functions/macros, and a hash table:

+ =*X-TABLE*= : hashtable
+ =#'symbol-x, #'(setf symbol-x)= : accessor
+ =#'x-boundp= : boolean
+ condition =UNBOUND-X=
+ macro =(X-LET (binding...) body)= : binding

In general, it should be avoided to define a namespace for something that
actually overlaps with the other in its idea. For example, consider
defining a namespace for a function defined by =defcached= in
[[https://github.com/AccelerationNet/function-cache][function-cache]].  As is implemented in =defcached=, the cache object
is worth a namespace, but the function itself should be in the
function namespace (of course), and *not* in a separate namespace.

* Macro NAMESPACE-LET

=LET= with ability to lexically bind any value in the namespace.
Example:

#+BEGIN_SRC lisp
(namespace-let ((#'x (y) (1+ y))
                ((macro x) (y) (1+ y))
                ((macro y) (y) (1+ y))
                (#'x (y) (1+ y))
                ((macro y) (y) (1+ y))
                ((symbol-macro sm) 0)
                (b 0))
  (let ((b 1))
    (print :x)))

;; (PROGN
;;  (FLET ((X (Y)
;;           (1+ Y)))
;;    (MACROLET ((X (Y)      ; same kinds of bindings are merged
;;                 (1+ Y))   ; as much as possible
;;               (Y (Y)
;;                 (1+ Y)))
;;      (FLET ((X (Y)
;;               (1+ Y)))
;;        (MACROLET ((Y (Y)
;;                     (1+ Y)))
;;          (SYMBOL-MACROLET ((SM 0))
;;            (LET ((B 0))
;;              (PROGN
;;               (LET ((B 1))
;;                 (PRINT :X))))))))))

;; (restart name), (handler name) expands into restart/handler-bind
(namespace-let (((restart continue)
                 (lambda (c)
                   (declare (ignore c))
                   (print :hi!))))
  (let ((b 1))
    (print :x)))

;; (PROGN
;;  (RESTART-BIND ((CONTINUE (LAMBDA (C) (DECLARE (IGNORE C)) (PRINT :HI!))))
;;    (PROGN
;;     (LET ((B 1))
;;       (PRINT :X)))))

;; Define a namespace. It automatically defines:
;; + symbol-test
;; + (setf symbol-test)
;; + unbound-test
;; + test-boundp
(define-namespace test)
;; result type of the accessor can be added (optionally) for the increased efficiency.
(define-namespace test fixnum)

(setf (symbol-test 'a) 0)
(print (symbol-test 'a)) ; --> 0
(print (symbol-test 'b)) ; --> error: UNBOUND-TEST signalled

(test-boundp 'a) ; --> t

;; Lexical binding
(funcall
 (namespace-let (((test a) 1))
   (lambda ()
     (symbol-test 'a)))) ; --> 1

;; (FUNCALL
;;  (PROGN
;;    (LET ((#:TEMP1976 1))
;;      (MACROLET ((SYMBOL-TEST (&WHOLE WHOLE X)
;;                   (IF (EQUAL X ''A)
;;                       '#:TEMP1976
;;                       WHOLE)))
;;        (PROGN (LAMBDA () (SYMBOL-TEST 'A)))))))

(symbol-test 'a) ; --> 0

;; flet-style: binding constructs specialized to that namespace
(let (x)
    (test-let ((a 1))
      (setf x 
            (lambda ()
              (symbol-test 'a))))
    (is (= 1 (funcall x))))

#+END_SRC

* I'm Asking for Help

I'm wondering which abbreviation to =namespace-let= is appropriate.
It should be something consistent with the historic name as =let=.
However, I do not like names like =let+= because they are not
self-expressive --- =let+= does not describe how it's different from the
original =let=.  =bind= and =where= are not considered good either, due to the
similar reason.

Simply, =nlet=? (@masatoi0 has kindly gave me an advice: =nslet= is better
to avoid confusion with the abbreviation of =named-let=.) Or, make it =let=
and force the user to shadow =cl:let=?  (nah I don't like it.)  Hope
there'd be a crazy bright idea.

* Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.2.8 on X86 Linux 3.13.0-44-generic (author's environment)

Also, it depends on the following libraries:

+ alexandria by ** :
    Alexandria is a collection of portable public domain utilities.
+ introspect-environment by *Bike* :

* Author & Copyright

Copyright (c) 2015 Masataro Asai (guicho2.71828@gmail.com)

Licensed under the LLGPL License.
