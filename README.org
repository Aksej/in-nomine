
#+BEGIN_SRC
Long time ago, in a galaxy far far away... 

It is a period of a civil war. Lisp-2
aliens, striking from the function
namespace, have fought for the
design of their language against lisp-1.
#+END_SRC

* Introduction

# However, destructuring is merely
# a syntax sugar for writing the accessor.

There are several libraries for extending =let=.
Most of them goes toward destructuring, e.g., allowing
=&some-fancy-directive= in the argument list.
However, destructuring is now considered
obsolete: it is superseded by pattern-matching, which
cleanly combines =cond=, =typecase= and destructuring.

Those =let= extensions are subject to a variation of greenspun's rule: they
are the /ad hoc, informally-specified, bug-ridden, slow implementation of
half of pattern-matching in ML/. (And I favor [[https://github.com/m2ym/optima][optima]] in this sense.) Now it
comes to my mind: what could be *the other* orthogonal aspect
that could be combined with =let=, or, =let + cond = pattern matching= ?

Then I noticed an oddness in flet, macrolet, labels, let,
symbol-macrolet. Pattern matching works in the value namespace only. Also,
whil special bindings for /namespaces/ can be trivially implemented with a
hash table, the lexical binding is not --- it's worth a library.  This is
what this library is for.

* Namespaces in CL

By /namespace/ I don't mean a /package/,
which is a way to manage symbols. It is orthogonal to /namespace/.

CL already has major 2 namespaces, /function/ namespace and /value/
namespace (or /variable/ namespace), but there are actually more --- e.g.,
there are also /class/ namespace. Same symbol can represent different
objects in each namespace. For example, all these below can coexist in a
same file without errors, and each object is accessible with the
corresponding function.

#+BEGIN_SRC lisp
(in-package :cl-user)

(defclass foo () ())
(defun foo () nil)
(defvar foo 1)

(find-class 'foo)      ; -> #<STANDARD-CLASS FOO>
(symbol-function 'foo) ; -> #<FUNCTION FOO>
(symbol-value 'foo)    ; -> 1

(make-instance 'bar)   ; -> SIMPLE-ERROR
(symbol-function 'bar) ; -> UNDEFINED-FUNCTION
(symbol-value 'bar)    ; -> UNBOUND-VARIABLE
#+END_SRC

| namespace | accessor        | unbound condition  | boundp  | binding     |
|-----------+-----------------+--------------------+---------+-------------|
| class     | find-class      | SIMPLE-ERROR       | n/a     | n/a         |
| function  | symbol-function | UNDEFINED-FUNCTION | fboundp | flet,labels |
| value     | symbol-value    | UNBOUND-VARIABLE   | boundp  | let         |

/Some/ namespaces in CL can be said to overlap with each other. For example:

+ *class* namespace --- with *type*, *condition* and *struct* namespace
+ *function* namspace --- with *macro-function* and *generic-function* namespace
+ *value* namespace --- with *symbol-macro* namespace.

* Macro DEFINE-NAMESPACE

: (define-namespace name &optional (expected-type t) (binding t))

This macro defines a namespace. For the given name of namespace X,
DEFINE-NAMESPACE defines 4 functions/macros, and an internal hash table:

+ =*X-TABLE*= : hashtable
+ =#'symbol-x, #'(setf symbol-x)= : accessor, special binding. Optionally,
  =expected-type= provides =ftype= proclamation and results in the
  better optimization. =expected-type= is not evaluated.
+ =#'x-boundp= : boolean
+ condition =UNBOUND-X=
+ macro =(X-LET (binding...) body)= : lexical binding. Can be turned off
  when =binding= is nil.

In general, it should be avoided to define a namespace for something that
actually overlaps with the other in its idea. For example, consider
defining a namespace for a function defined by =defcached= in
[[https://github.com/AccelerationNet/function-cache][function-cache]].  As is implemented in =defcached=, the cache object
is worth a namespace, but the function itself should be in the
function namespace (of course), and *not* in a separate namespace.

Note that /namespace/ itself has its own namespace.

Examples are in [[EXAMPLE.org]] .

* Macro NAMESPACE-LET

=LET= with ability to lexically bind any value in the namespace.
It currently supports /function, labels, value, symbol-macro, macrolet,
restart, handler/ namespaces and the user-defined namespaces.

Full examples are in [[EXAMPLE.org]] .

#+BEGIN_SRC lisp
(namespace-let ((#'x (y) (1+ y))
                ((macro x) (y) (1+ y))
                ((macro y) (y) (1+ y))
                (#'x (y) (1+ y))
                ((label y) (y) (y y))
                ((symbol-macro sm) 0)
                (b 0))
  (let ((b 1))
    (print :x)))

;; (PROGN
;;  (FLET ((X (Y) (1+ Y)))
;;    (MACROLET ((X (Y) (1+ Y))
;;               (Y (Y) (1+ Y))) ; same kinds of bindings are merged
;;      (FLET ((X (Y) (1+ Y)))
;;        (LABELS ((Y (Y) (Y Y)))
;;          (SYMBOL-MACROLET ((SM 0))
;;            (LET ((B 0))
;;              (PROGN
;;               (LET ((B 1))
;;                 (PRINT :X))))))))))
#+END_SRC

* Design?

I'm wondering which abbreviation to =namespace-let= is appropriate.
It should be something consistent with the historic name as =let=.
However, I do not like names like =let+= because they are not
self-expressive --- =let+= does not describe how it's different from the
original =let=.  =bind= and =where= are not considered good either, due to the
similar reason.

Simply, =nlet=? (@masatoi0 has kindly gave me an advice: =nslet= is better
to avoid confusion with the abbreviation of =named-let=.) Or, make it =let=
and force the user to shadow =cl:let=?  (nah I don't like it.)  Hope
there'd be a crazy bright idea.

* Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.2.8 on X86 Linux 3.13.0-44-generic (author's environment)

Also, it depends on the following libraries:

+ alexandria by ** :
    Alexandria is a collection of portable public domain utilities.
+ introspect-environment by *Bike* :

* Author & Copyright

Copyright (c) 2015 Masataro Asai (guicho2.71828@gmail.com)

Licensed under the LLGPL License.
