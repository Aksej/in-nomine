
#+BEGIN_SRC
Long time ago, in a galaxy far far away... 

There used to be a civil war. Lisp
aliens, striking from the function
namespace, have fought for the
design of their language against lisp-1.

After the battle, some aliens managed
to find an easy way to the lisper's
moderate weapon, LISP-N, an
not-so-developped idea with enough
power to provide arbitrary number of namespaces.

Pursued by the lot's of let+destructuring libraries,
this small library provides ....
#+END_SRC

Well, this would be enough. Flat joke. Let's go to the example.

#+BEGIN_SRC lisp
(namespace-let ((#'x (y) (1+ y))
                ((macro x) (y) (1+ y))
                ((macro y) (y) (1+ y))
                (#'x (y) (1+ y))
                ((macro y) (y) (1+ y))
                ((symbol-macro sm) 0)
                (b 0))
  (let ((b 1))
    (print :x)))

;; (PROGN
;;  (FLET ((X (Y)
;;           (1+ Y)))
;;    (MACROLET ((X (Y)      ; same kinds of bindings are merged
;;                 (1+ Y))   ; as much as possible
;;               (Y (Y)
;;                 (1+ Y)))
;;      (FLET ((X (Y)
;;               (1+ Y)))
;;        (MACROLET ((Y (Y)
;;                     (1+ Y)))
;;          (SYMBOL-MACROLET ((SM 0))
;;            (LET ((B 0))
;;              (PROGN
;;               (LET ((B 1))
;;                 (PRINT :X))))))))))

;; (restart name), (handler name) expands into restart/hander-bind
(namespace-let (((restart continue)
                 (lambda (c)
                   (declare (ignore c))
                   (print :hi!))))
  (let ((b 1))
    (print :x)))

;; (PROGN
;;  (RESTART-BIND ((CONTINUE (LAMBDA (C) (DECLARE (IGNORE C)) (PRINT :HI!))))
;;    (PROGN
;;     (LET ((B 1))
;;       (PRINT :X)))))

;; Define a namespace. It automatically defines:
;; + symbol-test
;; + (setf symbol-test)
;; + unbound-test
;; + test-boundp
(define-namespace test)
;; result type of the accessor can be added (optionally) for the increased efficiency.
(define-namespace test fixnum)

(setf (symbol-test 'a) 0)
(print (symbol-test 'a)) ; --> 0
(print (symbol-test 'b)) ; --> error: UNBOUND-TEST signalled

(test-boundp 'a) ; --> t

;; Lexical binding
(funcall
 (namespace-let (((test a) 1))
   (lambda ()
     (symbol-test 'a)))) ; --> 1

;; (FUNCALL
;;  (PROGN
;;    (LET ((#:TEMP1976 1))
;;      (MACROLET ((SYMBOL-TEST (&WHOLE WHOLE X)
;;                   (IF (EQUAL X ''A)
;;                       '#:TEMP1976
;;                       WHOLE)))
;;        (PROGN (LAMBDA () (SYMBOL-TEST 'A)))))))

(symbol-test 'a) ; --> 0

#+END_SRC

* Idea

Destructuring is obsolete. It is superseded by pattern-matching,
which cleanly combines =cond=, =typecase= and destructuring.

Destructuring is one form of binding. It is a binding construct.
I want to stress it out. *Destructuring is a binding construct.* Therefore
*it is not orthogonal from* =let=, which is also a binding construct.

I personally feel combining =let= and =destructuring= is NOT cool because
it contains this kind of redunduncy. It is not a smart integration of
different ideas into a new horizon, while pattern-matching is.

There should be another way around. I noticed an oddness in flet, macrolet,
labels, let, symbol-macrolet. Namespace can be trivially implemented with a
hash table, but the lexical binding would be something that's been missed I
guess.  That's what this library is for.

* I'm Asking for Help

I'm wondering which abbreviation to =namespace-let= is appropriate.
It should be something consistent with the historic name as =let=.
However, I do not like names like =let+= because they are not
self-expressive --- =let+= does not describe how it's different from the
original =let=.  =bind= and =where= are not considered good either, due to the
similar reason.

Simply, =nlet=? Or, make it =let= and force the user to shadow =cl:let=?
(nah I don't like it.)
Hope there'd be a crazy bright idea.

* Dependencies

This library is at least tested on implementation listed below:

+ SBCL 1.2.8 on X86 Linux 3.13.0-44-generic (author's environment)

Also, it depends on the following libraries:

+ alexandria by ** :
    Alexandria is a collection of portable public domain utilities.
+ introspect-environment by *Bike* :

* Author & Copyright

Copyright (c) 2015 Masataro Asai (guicho2.71828@gmail.com)

Licensed under the LLGPL License.
